module Map (map', map'') where

map' :: (a -> b) -> [a] -> [b]
map' _ [] = []
map' f (x : xs) = f x : map' f xs -- 先頭要素に引数で渡された関数を渡して連結する
-- e.g. map' show [1, 2, 3, 4]の場合
-- = map' show 1 : [2, 3, 4]
-- = show 1 : map' show [2, 3, 4]
-- = "1" : map' show [2, 3, 4]
-- = "1" : show 2 : map' show [3, 4]
-- = "1" : "2" : map' show [3, 4]
-- = "1" : "2" : map' show [3, 4]
-- = "1" : "2" : show 3 : map' show [4]
-- = "1" : "2" : "3" : map' show [4]
-- = "1" : "2" : "3" : show 4 : map' show []
-- = "1" : "2" : "3" : "4" : map' show []
-- = "1" : "2" : "3" : "4" : []
-- = ["1", "2", "3", "4"]

-- foldrで実装する
-- foldr (:) []を使うと配列をそのまま返せる。
-- ghci> foldr (:) [] [1, 2, 3, 4, 5]
-- [1,2,3,4,5]
-- これを利用して、:にfを関数合成することでmapが実現できる。
map'' :: (a -> b) -> [a] -> [b]
map'' f list = foldr ((:) . f) [] list

-- e.g. map'' show [1, 2, 3, 4]の場合
-- foldr ((:) . show) [] [1, 2, 3, 4]
-- foldr ((:) . show) [] [1, 2, 3, 4]
-- ((:) . show) 1 (foldr ((:) . show) [] [2, 3, 4])
-- (:) (show 1) (foldr ((:) . show) [2, 3, 4])
-- (:) "1" (foldr ((:) . show) [2, 3, 4])
-- (:) "1" (((:) . show) 2 (foldr ((:) . show) [3, 4]))
-- (:) "1" ((:) (show 2) (foldr ((:) . show) [3, 4]))
-- (:) "1" ((:) "2" (foldr ((:) . show) [3, 4]))
-- = (:) "1" ((:) "2" (foldr ((:) . show) [] [3, 4]))
-- = (:) "1" ((:) "2" (((:) . show) 3 (foldr ((:) . show) [] [4])))
-- = (:) "1" ((:) "2" ((:) (show 3) (foldr ((:) . show) [] [4])))
-- = (:) "1" ((:) "2" ((:) "3" (foldr ((:) . show) [] [4])))
-- = (:) "1" ((:) "2" ((:) "3" (((:) . show) 4 (foldr ((:) . show) [] []))))
-- = (:) "1" ((:) "2" ((:) "3" ((:) (show 4) (foldr ((:) . show) [] []))))
-- = (:) "1" ((:) "2" ((:) "3" ((:) "4" [])))
-- = ["1", "2", "3", "4"]

main :: IO ()
main = do
  print $ map' show [1, 2, 3, 4]
  print $ map'' show [1, 2, 3, 4]