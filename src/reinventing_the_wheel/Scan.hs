module Scan (scanl', scanr') where

scanl' :: (b -> a -> b) -> b -> [a] -> [b]
scanl' _ q [] = [q]
scanl' f q (x : xs) = q : scanl' f (f q x) xs

-- e.g. scanl (+) 5 [1, 2, 3, 4]の場合
-- scanl' (+) 5 1: [2, 3, 4]
-- = 5 : scanl' (+) ((+) 5 1) [2, 3, 4]
-- = 5 : scanl' (+) ((+) 5 1) [2, 3, 4]
-- = 5 : scanl' (+) (6) [2, 3, 4]
-- = 5 : 6 : scanl' (+) ((+) 6 2) [3, 4]
-- = 5 : 6 : scanl' (+) (8) [3, 4]
-- = 5 : 6 : 8: scanl' (+) ((+) 8 3) [4]
-- = 5 : 6 : 8: scanl' (+) (11) [4]
-- = 5 : 6 : 8: 11 : scanl' (+) ((+) 4) []
-- = 5 : 6 : 8: 11 : scanl' (+) ((+) 11 4) []
-- = 5 : 6 : 8: 11 : scanl' (+) (15) []
-- = 5 : 6 : 8: 11 : [15]

scanr' :: (a -> b -> b) -> b -> [a] -> [b]
scanr' _ q [] = [q]
scanr' f q (x : xs) =
  let rest@(r : _) = scanr' f q xs -- @はas-pattern
   in f x r : rest

-- e.g. scanr' (+) 5 [1, 2, 3, 4]の場合
-- scanr' (+) 5 1 : [2, 3, 4]

-- rest@(r : _) = scanr' (+) 5 [2, 3, 4]を再帰的に展開すると
-- scanr' (+) 5 [3, 4] --> scanr' (+) 5 [4] --> scanr' (+) 5 [] = [5]のようにrestは展開される。最終的にx = 4の時r=5となるのでこれを使って上に戻ると
-- f x r : rest = (+) 4 5 : [5] = [9, 5] = scanr' 5 [4]

-- x = 3の時、rest = scanr' (+) 5 [4] = [9, 5]なので r = 9
-- f x r : rest = (+) 3 9 : [9, 5] = [12, 9, 5] = scanr ' 5 [3, 4]

-- x = 2の時、rest = scanr' (+) 5 [3, 4] = [12, 9, 5]なので r = 12
-- f x r : rest = (+) 2 12 : [12, 9, 5] = [14, 12, 9, 5] = scanr' 5 [2, 3, 4]

-- x = 1の時 rest = scanr' (+) 5 [2, 3, 4] = [14, 12, 9, 5]なので r = 14
-- f x r : rest = (+) 1 14 : [14, 12, 9, 5] = [15, 14, 12, 9, 5]

main :: IO ()
main = do
  print $ scanl' (+) 5 [1, 2, 3, 4] -- [5, 5 + 1, 5 + 1 + 2, 5 + 1 + 2 + 3, 5 + 1 + 2 + 3 + 4] = [5, 6, 8, 11, 15]
  print $ scanr' (+) 5 [1, 2, 3, 4] -- [15, 14, 12, 9, 5]